import numpy as np
from vdf import vdf

def uniform_sample_frustum(zlower, zupper, alpha_rad, n=n):
    '''
    Function to generate n uniform random samples 
    on the sensitive domain for a faraday cup
    measurement.

    Parameters:
    -----------
    def 
    zlower        lower limit in speed (vz) for the window
    zupper        upper limit in speed (vz) for the window
    alpha_rad     maximum inflow angle to which the cup is sensitive
    n             number of samples desired (default 1000)

    Returns:
    --------
    phi           phi angles (deflection x_FC=0) for each sample
    theta         theta angles (deflection y_FC=0)
    r             radial speed
    dvol          differential volume in phase space assigned to each sample
    zlower        [echo from input]
    zupper        [echo from input]
    alpha_rad     [echo from input]
    '''
    if(len(n) == 0):
        n = 1000.
    
    z0 = zlower
    dz0 = zupper - zlower
    r0 = z0 * np.tan(alpha_rad)
    r1 = (z0+dz0) * np.tan(alpha_rad)
    
    # draw points from the rectangular prism that circumscribes the domain:

    # (a) calculate the ratio of volumes and adjust the number of 
    # samples
    vol = (dz0 * np.pi/3.) * (r0**2 + r1**2 + r0*r1)
    recvol = dz0 * (2.*r1)**2
    n0 = 1.1 * n * recvol / vol
    # (b) generate uniform points on the prism
    xrand = 2. * r1 * (randomu(seed, n0) - 0.5)
    yrand = 2. * r1 * (randomu(seed, n0) - 0.5)
    zrand = z0 + dz0 * randomu(seed, n0)
    # (c) select for points inside the domain 
    tanalpha_rad = np.sqrt(xrand**2 + yrand**2) / zrand
    inside = where(tanalpha_rad lt tan(alpha_rad), nin)
    inside = inside[0: (nin<n)-1]
    x = xrand[inside]
    y = yrand[inside]
    z = zrand[inside]

    # calculate polar coordinates and differential volume elements
    phi = np.arctan(x, z)
    theta = np.arctan(y,z)
    r = np.sqrt(x**2 + y**2 + z**2)
    dvol = vol/n + (0. * r)

    # package output structure
    return {phi:phi, theta:theta, r:r, dvol:dvol, zlower:zlower, zupper:zupper, alpha_rad:alpha_rad}

def rescale_frustum_samples(zlower, zupper, input, debug=debug):
    '''
    function to rescale the set of samples generated by uniform_sample_frustum(),
    and their associated differentials to a new modulator window
    without changing their polar angle. 

    The advantage of using this function is that the samples can be recycled without
    additional calls to the random number generator or the cup geometrical response.

    The disadvantage is that the new domain is not uniformly sampled.

    INPUTS
    zlower        lower limit in speed (vz) for the window
    zupper        upper limit in speed (vz) for the window
    input         anonymous structure as generated by uniform_sample_frustum()

    OUTPUT anonymous structure containing:
    phi           phi angles (deflection x_FC=0) for each sample
    theta         theta angles (deflection y_FC=0)
    r             radial speed
    dvol          differential volume in phase space assigned to each sample
    zlower        [echo from input structure]
    zupper        [echo from input structure]
    alpha_rad     [echo from input structure]
    '''

    cosalpha = 1./np.sqrt(np.tan(input.phi)**2 + np.tan(input.theta)**2 + 1.)
    tanalpha_max = np.tan(input.alpha_rad)
    z0 = input.r * cosalpha
    x0 = np.tan(input.phi) * z0
    y0 = np.tan(input.theta) * z0
    zlo0 = input.zlower
    dz0 = input.zupper - input.zlower

    # find scale factor for z position in the old frustum
    lamda = (z0 - zlo0) / dz0

    # calculate the new z coordinate by rescaling
    dz1 = zupper - zlower
    newz = zlower + dz1*lamda
    newr = newz / cosalpha

    # rescale the volume element
    newdvol = input.dvol * (dz1/dz0) * (newr/input.r)**2

    if keyword_set(debug) then begin
        # perform consistency check:
        radius0 = zlower*tanalpha_max
        radius1 = zupper*tanalpha_max
        newvol = (dz1*np.pi/3.)*(radius0^2 + radius1^2 + radius0*radius1)
        print, 'net volume transform error: ', 100.*(total(newdvol) - newvol)/newvol, '%'

    return, {phi:input.phi, theta:input.theta, r:newr, dvol:newdvol,
            zlower:zlower, zupper:zupper, alpha_rad:input.alpha_rad}

def rays_to_xyzfc(input):
    cosalpha = 1./np.sqrt(np.tan(input.phi)**2 + np.tan(input.theta)**2 + 1.)
    z0 = input.r * cosalpha
    x0 = np.tan(input.phi) * z0
    y0 = np.tan(input.theta) * z0
    return [[x0], [y0], [z0]]

# wrapper for the spc geometry function 
def calculate_effective_area_cm2(phi_rad, theta_rad):
    # spc function takes arguments in degrees and returns sensitive area in mm^2
    return 100. * psp_swp_spc_coldspot(phi_rad * 180/np.pi, theta_rad * 180/np.pi)

def cup_response_numflux_1step(vz_lo, vz_hi, fv, effarea, ps_samples):
    nsensors = (size(effarea, /dim))[0]
    numflux = np.zeros(nsensors)
    ps_samples = rescale_frustum_samples(vz_lo, vz_hi, ps_samples)
    vxyz = rays_to_xyzfc(ps_samples)
    f = fv.evaluate(vxyz)
    # flux = const*vz * Area * f(v) * d3v
    # units [const]*[km/s]*[cm2]*[cm-3 km-3 s3]*[km3 s-3] = [const]*[km/cm] s-1 = s-1
    # so [const] must have units of cm per km
    cmperkm = 1e5
    numflux[0] = cmperkm*total(reform(vxyz[*,2])*reform(effarea[0,*])*f*ps_samples.dvol, /nan)
    numflux[1] = cmperkm*total(reform(vxyz[*,2])*reform(effarea[1,*])*f*ps_samples.dvol, /nan)
    numflux[2] = cmperkm*total(reform(vxyz[*,2])*reform(effarea[2,*])*f*ps_samples.dvol, /nan)
    numflux[3] = cmperkm*total(reform(vxyz[*,2])*reform(effarea[3,*])*f*ps_samples.dvol, /nan)
    return numflux

def cup_response_numflux_spectrum(vz_lo, vz_hi, fv, effarea, ps_samples):
    nsensors = (size(effarea, /dim))[0]
    nsteps = len(vz_lo)
    numflux = np.zeros((nsensors, nsteps))

    for i in range(0, nsteps):
        numflux[:,i] = cup_response_numflux_1step(vz_lo[i], vz_hi[i], fv, effarea, ps_samples)

    return numflux

for __name__=='__main__':
    # 0. define constants
    integration_pts = 1000.
    spc_fov_radians = 44. * np.pi/180.

    # 1a. set up a vz spectrum range
    nsteps = 30
    vlo = 100. + 20. * np.arange(nsteps)
    vhi = vlo + 20.

    # 1b. initialize an example velocity distribution function
    myvdf = vdf('maxwellian_vdf', {vx:100., vy:50., vz:250., w:50., n:1000.})

    # 2. initialize the samples, i.e.
    ps_samples = uniform_sample_frustum(vlo[0], vhi[0], spc_fov_radians, n=integration_pts)

    # 3. calculate the geometric factors
    effarea = calculate_effective_area_cm2(ps_samples.phi, ps_samples.theta)

    # 4. calculate the responses
    numflux = cup_response_numflux_spectrum(vlo, vhi, myvdf, effarea, ps_samples)

    '''
    if keyword_set(debug) then begin
    !p.multi = [0, 2, 2]
    yrange = minmax(numflux)
    plot, vlo, numflux[0,*], yrange=yrange
    plot, vlo, numflux[1,*], yrange=yrange
    plot, vlo, numflux[2,*], yrange=yrange
    plot, vlo, numflux[3,*], yrange=yrange
    stop
    endif
    
    end
    '''
